# なぜ第一原理計算コードを Rust で書き直すのか

C や Fortran で書かれた大規模なレガシー第一原理計算コード（数十万行、数百のグローバル変数）を、AI エージェントを活用して Rust で新たに設計・実装できる。そしてそれは、第一原理計算コミュニティが直面している問題を解決する。

[OpenMX](https://www.openmx-square.org/)（DFT コード、C 言語約39万行）をケーススタディとして取り上げるが、同様の特徴を持つあらゆる大規模計算科学コードに適用可能な戦略だ。

Rust の知識がなくても読める。

> **第一原理計算コードの書き直しで最も難しいのは、書き直し作業そのものではなく、正しい抽象化を見つけることだ。** crate（モジュール）の境界をどこに引くか。どの演算が計算科学の共通基盤に属し、どれが DFT 固有のロジックか。ハミルトニアン構築のインターフェースはどうあるべきか。これらは物理の問いであって、プログラミングの問いではない。正しい答えを出すには、第一原理計算の物理学者の直感、第一原理からテンソルネットワークまで横断的な経験を持つ研究者（品岡ら）の知見、AI エージェントによる候補設計の高速な具現化、この三者の融合が必要だ。

---

## Part I: レガシー第一原理計算コードの問題

### 思い当たる節はないだろうか

大規模な第一原理計算コードを保守・利用していれば、以下のいくつかには身に覚えがあるだろう。

- **ビルドシステムを理解しているのは一人だけ。** MPI、BLAS/LAPACK、ScaLAPACK、FFTW、ELPA への依存があり、新しいマシンでのコンパイルに暗黙知が必要。
- **コアに手を出す勇気がない。** SCF ループ、力の計算、Poisson ソルバーは動いているが、コードが絡み合っていて、一箇所の修正が別の場所を壊しかねない。
- **テストが遅く浅い。** フルの統合テスト（「バルク Si の全エネルギーが合うか？」）しかなく、ユニットテストは存在しない。コンポーネントを分離できないからだ。
- **新しい物理の追加が苦痛。** 新しい交換相関汎関数の追加に7ファイルの修正と50個のグローバル変数の理解が必要。
- **オリジナルの開発者が引退しようとしている。** バスファクターは1。その人がいなくなれば、コードは死ぬ。

### 具体例: OpenMX 3.9

OpenMX は擬原子局在基底関数に基づく多機能 DFT コードで、コリニア・非コリニア磁性、O(N) 法、量子輸送（NEGF）、LDA+U、ハイブリッド汎関数、分子動力学をサポートする。世界中で使われている本格的なプロダクションコードだ。

| 指標 | 値 |
|------|-----|
| C ソースファイル | 346 |
| ヘッダファイル | 36 |
| Fortran ファイル | 4（ELPA バインディング） |
| C の総行数 | 390,782 |
| 最大単一ファイル | `DFTD3vdW_init.c`（33,727行） |
| `openmx_common.h` 内のグローバル変数 | 330以上 |

346個すべてのソースファイルが `openmx_common.h` を include している。このヘッダに330を超える `extern` グローバル変数が宣言されており、原子座標、基底関数データ、グリッド情報、MPI 分散テーブル、SCF 制御フラグ、スピンパラメータ、Hubbard U の値などが含まれる。どのファイルのどの関数からも自由に読み書きできる。関数のシグネチャを読んでも、その関数がどの状態に依存し何を変更するかはわからない。

ビルドシステムは手書きの Makefile で、Intel MKL、ScaLAPACK、FFTW3、ELPA、MPI、OpenMP にリンクしている。7つの異なるスパコン向け設定がコメントアウトされており、自分のマシンで通すには手作業で編集が必要だ。

これは OpenMX への批判ではない。数十年かけて進化した大規模第一原理計算コードの標準的な姿だ。物理は優れている。ソフトウェア工学はその時代の産物にすぎない。

### 現状維持は持続不可能

第一原理計算コミュニティでは、以下の問題が同時に進行している。

1. **コードは大きくなる一方。** 輸送、光学特性、トポロジカル不変量、機械学習ポテンシャルが次々と追加される。
2. **メンテナは減る一方。** オリジナル開発者が引退・異動していく。
3. **ハードウェアは多様化する一方。** CPU、GPU、ARM、ヘテロジニアスノードへの対応が増える。
4. **ユーザの期待は高まる一方。** Python インターフェース、再現可能なワークフロー、クラウドデプロイが求められる。

330個のグローバル変数を抱える39万行の C コードにパッチを当て続けるのは、現実的な道ではない。

---

## Part II: なぜ Rust なのか（そしてなぜ C++ ではないのか）

### Rust を学ぶ必要はない

最も重要な点なので最初に述べる。

AI エージェント（Claude Code、Cursor、GitHub Copilot など）の時代に、**人間が Rust を一行ずつ書く必要はない**。AI エージェントが所有権アノテーション、ライフタイム境界、トレイト実装といった機械的な複雑さを処理し、人間は**物理、アルゴリズム、抽象化、正しさ**に集中する。

Rust コンパイラは、エージェントが書いたコードを検証し、メモリバグ、データ競合、型エラーをコンパイル時に検出する。疲れることなくバグのクラスを見逃さない自動レビュアーだ。

物理学者が**できる必要があること**：

- Rust の関数シグネチャを読む（型、入力、出力）。数学の記法に似ている
- 抽象化が物理的に正しいか判断する
- `cargo test` を実行して出力を読む
- AI エージェントに何を変えるべきか伝える

物理学者が**できる必要のないこと**：

- 所有権ルールの暗記
- ライフタイムアノテーションの記述
- 借用チェッカーのエラーのデバッグ
- トレイトディスパッチの内部動作の理解

これらは AI が処理し、コンパイラが検証する。

### なぜ C++ ではないのか

計算物理学者が必ず問う質問だ。

**C のコードは C++ としてそのままコンパイルできるため、何も改善しない。** OpenMX の346個の C ファイルを C++ コンパイラでコンパイルしても、同一に動作する。C++ には安全機能（RAII、スマートポインタ、`std::vector`）があるが、コンパイラはそれらの使用を強制しない。安全性はオプトインだ。C++ に移植されたレガシー C コードは、拡張子が `.cpp` に変わっただけの安全でない C コードのままである。

**Rust の安全性はデフォルトだ。** すべてのコードがメモリ安全であり、安全でない操作が必要な箇所だけ `unsafe {}` と明示する。すべての unsafe が可視的で監査可能になる。リファクタリングを進めるにつれて `unsafe` が減り、コンパイラの保証が増えていく。

**グローバルな可変状態はコンパイルエラーになる。** C/C++ では330個のグローバル変数は合法だが、Rust では可変なグローバル状態には `unsafe` か同期プリミティブが必要になる。crate に分割すると、330個のグローバル変数というパターンは物理的に生き残れない。コンパイラがそれを排除する。

**crate 境界がモジュール性を強制する。** Rust のワークスペースは明示的な依存関係宣言を持つ crate で構成される。crate A は crate B の非公開部分にアクセスできず、循環依存は禁止。12個の crate に分割すると、コンパイラがクリーンなインターフェースを**強制する**。C++ ではヘッダやライブラリの境界はビルドシステムの慣習にすぎない。

**差分コンパイルが crate 単位で効く。** 一つの crate を変更すると、その crate と依存先だけが再コンパイルされる。交換相関 crate を変えても Poisson ソルバーや I/O 層の再コンパイルは発生しない。`openmx_common.h` のような共有ヘッダを持つ C/C++ では、そのヘッダの変更で全346ファイルが再コンパイルされる。

**C++ には標準的なパッケージシステムがない。** C++ の依存関係管理は CMake に頼ることが多いが、CMakeLists.txt の書き方に標準はなく、プロジェクトごとにやり方が異なる。依存関係が正しく解決されているかを機械的に検証するのが難しい。AI に検証させることはできるが、時間がかかる。Rust の `cargo` では `Cargo.toml` に依存を宣言するだけで、解決・ビルド・バージョン整合性の検証が一瞬で完了する。12個の crate からなるワークスペースでも `cargo build` 一発でビルドが通る。

**AI エージェントは C++ より Rust で効果的に動く。** 両言語とも AI にとって「書く」コストは同じだ。違いは「検証」にある。AI が書いた C++ コードがコンパイルを通っても、未定義動作や use-after-free が残りうる。Rust コードがコンパイルを通れば、メモリ安全性バグのクラス全体が排除される。AI の edit→compile→test サイクルの生産性が劇的に上がる。

---

## Part III: エコシステムは準備ができている

### 外部ライブラリ

第一原理計算コードに必要な外部ライブラリは、すべて Rust から利用可能だ。

| ライブラリ | Rust crate | 備考 |
|-----------|-----------|------|
| BLAS/LAPACK | [blas](https://crates.io/crates/blas) / [lapack](https://crates.io/crates/lapack) | OpenBLAS, MKL 等に対応。[cblas-inject](https://crates.io/crates/cblas-inject) によるランタイム注入も可 |
| MPI | [rsmpi](https://github.com/rsmpi/rsmpi) (crate名: [mpi](https://crates.io/crates/mpi)) | MPI-3.1 準拠。[rsmpi-rt](https://github.com/tensor4all/rsmpi-rt) によるランタイムロードも可 |
| HDF5 | [hdf5](https://crates.io/crates/hdf5) | スレッドセーフなラッパー。[hdf5-rt](https://github.com/tensor4all/hdf5-rt) によるランタイムロードも可 |
| FFT | [fftw](https://crates.io/crates/fftw) / [rustfft](https://crates.io/crates/rustfft) | FFTW3 バインディング、または純 Rust 実装 |
| CUDA | [cudarc](https://crates.io/crates/cudarc) | cuBLAS, cuSOLVER, cuSPARSE, cuRAND 等を含む安全なラッパー |

いずれも既存の C/Fortran ライブラリを呼び出す薄いラッパーであり、Rust で再実装しているわけではない。

### テンソル演算: tenferro-rs

密テンソル演算は、あらゆる第一原理計算コードが依存する計算の中核だ。[tenferro-rs](https://github.com/tensor4all/tenferro-rs) がこの中核を提供する Rust ワークスペースとして開発が進んでいる。

- **密テンソル**: ストライドビューとゼロコピースライシング
- **Einsum**: 縮約ツリー最適化付き
- **バッチ線形代数**: SVD、QR、LU、固有値分解
- **自動微分プリミティブ**（VJP/JVP）: 複素 SVD、QR 等の正しい微分規則付き
- **C-FFI**: DLPack 相互運用
- **デバイス抽象化**: CPU と GPU

tenferro-rs は12個の crate からなるワークスペースとして構成されており、DFT コードに対して提案するのと同じパターンだ。

### パッケージ配布

Rust のパッケージマネージャ `cargo` が純粋な Rust の依存関係をすべて自動処理する。CMake も `pkg-config` も `configure` も不要。

```bash
cargo build --release    # 全依存関係をダウンロードし、すべてをビルド
```

`cargo build --release` が実行時依存関係のない単一の実行ファイルを生成する。スパコン向けには `cargo vendor` で全依存関係のソースコードをローカルにコピーし、完全オフラインの再現可能ビルドが可能だ。7つのスパコン設定がコメントアウトされた Makefile は不要になる。

---

## Part IV: 書き直しの戦略

ここで提案するのは、レガシーコードを逐語的に Rust に翻訳する戦略ではない。39万行の C コードを少しずつ crate に分解していくのは現実的ではないし、その必要もない。

**元の C コードはそのまま残す。** 手を入れるのは、検証用の数値データを出力するコードを加えるときだけだ。一方、Rust 側では正しい抽象化を一から設計する。これにより、巨大なレガシーコードを段階的に改修するという長大な過程を丸ごとスキップできる。

### Phase 1: API スケルトンの設計（最も重要なフェーズ）

最も重要なフェーズであり、自動化できないフェーズだ。

問いは「`Force.c` をどう Rust にするか」ではない。真の問いは**正しい抽象化は何か**だ。crate の境界をどこに引くか。ハミルトニアン構築と固有値ソルバーの間でどんなデータが流れるべきか。運動エネルギーとポテンシャルの寄与は別の型にすべきか。密度行列はインターフェース境界で実空間にあるべきか、逆格子空間にあるべきか。

これらは物理の問いだ。三種類の専門性の融合が必要になる。

1. **第一原理計算の物理学者の直感。** DFT の実践者は、重なり行列とハミルトニアン行列が一般化固有値問題において異なる役割を持つことを知っている。それらはおそらく別の構築パイプラインに属すべきだと判断できる。OpenMX では類似した構造で構築されていたとしてもだ。API が「物理的に意味をなすか」を判断できるのは、物理を理解している人だけだ。

2. **分野横断的なアーキテクチャの知見。** 第一原理計算とテンソルネットワークの両方で研究を行ってきた品岡らは、単一の分野からは見えないパターンを見出せる。[tenferro-rs](https://github.com/tensor4all/tenferro-rs) が提供する密テンソル演算、einsum 縮約、バッチ線形代数、AD プリミティブはテンソルネットワーク固有ではなく、DFT コードが必要とするのと同じ演算だ。「共有すべき計算基盤」と「DFT 固有のロジック」の境界を引くには、両方の世界での経験が要る。

3. **AI による高速な具現化。** AI エージェントは「運動エネルギーとポテンシャルのハミルトニアン構築を別々のトレイトに分けて」という指示から、数秒でコンパイル可能な Rust コードを生成する。物理学者は Rust を書く必要はない。出来上がった API を見て「物理を捉えている」か「スピンの構造が違う」と言えばよい。関数本体が `todo!()` なので即座にコンパイルされる。議論 → 具現化 → `cargo check` → 評価 → 再設計、のループが回る。

crate 構造と公開インターフェース（関数シグネチャ、トレイト定義、データ型）を `todo!()` の本体で定義する。

```
openmx-rs/
├── openmx-basis/           # PAO 基底関数、擬ポテンシャル
├── openmx-grid/            # 実空間グリッド操作
├── openmx-hamiltonian/     # ハミルトニアン構築
├── openmx-xc/              # 交換相関汎関数
├── openmx-poisson/         # FFT ベース Poisson ソルバー
├── openmx-eigen/           # 固有値ソルバー（tenferro-rs を利用）
├── openmx-mixing/          # SCF mixing（DIIS, Kerker, Pulay）
├── openmx-scf/             # SCF ループ制御
├── openmx-force/           # 力・応力（または AD ベース）
├── openmx-transport/       # NEGF 量子輸送
├── openmx-md/              # 分子動力学
└── openmx-io/              # 入出力（OpenMX フォーマット互換）
```

スケルトンは数秒でコンパイルされる。本体が `todo!()` なので、再設計ループは思考速度で回る。物理学者が昼食前に5つの API 設計を却下しても、AI は5つすべてを具現化し終えている。

**最初から完璧な抽象化は必要ない。** スケルトンフェーズで速やかに収束するが、後で crate 境界が間違っていたとわかっても、境界を移動すればよい。C で39万行のコードを再構築するのは恐怖だ。何が壊れるかわからず、検出するテストもない。Rust では型システムとテストスイートの組み合わせで再構築が安全になる。コンパイラがインターフェース違反をコンパイル時に検出し、テストが数値回帰を実行時に検出する。

### Phase 2: 参照テストデータベースの構築

Rust の実装を書く前に、「正しい」とは何かを定義する。各 crate について参照入力と期待出力のセットを用意する。このデータはオリジナルの OpenMX から生成する。

この作業は機械的だ。OpenMX には既にテスト入力ファイルがある（`work/` に格納）。インプットファイルさえ決めれば、あとは AI エージェントが自律的に行える。

1. OpenMX の C コードに、各 SCF ステップ後の密度、ハミルトニアン行列要素、固有値、XC ポテンシャル、Hartree ポテンシャル、力などを出力するコードを追加する
2. 標準的な入力セット（バルク Si、分子、表面スラブ、磁性系）で実行する
3. 出力を参照データベース（HDF5 等）に収集する

結果として、crate ごとのテスト契約が得られる。

- `openmx-xc`: グリッド上の電子密度 → 交換相関エネルギーとポテンシャル
- `openmx-poisson`: 電荷密度 → Hartree ポテンシャル
- `openmx-eigen`: ハミルトニアンと重なり行列 → 固有値
- `openmx-scf`: 入力構造 → N SCF ステップ後の全エネルギーと力

テストが存在すれば、実装は「テストをパスさせる」仕事になる。AI エージェントが最も得意とするタスクだ。

### Phase 3: Rust による新規実装（AI エージェント、並列）

API とテスト契約が定まったら、AI エージェントが crate ごとに実装を書く。crate は独立しているので、複数エージェントが並列に作業できる。

- エージェント A が `openmx-xc` を実装
- エージェント B が `openmx-poisson` を実装
- エージェント C が `openmx-mixing` を実装

オリジナルの C コードはアルゴリズムの参考にはなるが、逐語的に翻訳するのではない。正しい抽象化の上に、正しいアルゴリズムを新たに実装する。差分コンパイルにより、各エージェントの edit→compile→test サイクルは秒単位で回る。

### Phase 4: オリジナルとの照合検証（AI エージェント、自動化）

ここで第一原理計算コードの決定的な強みが活きる。**DFT 計算は決定的だ。** 同じ入力は浮動小数点精度の範囲で同じ出力を生む。乱数もモンテカルロノイズも統計誤差もない。

この決定性のおかげで、自動検証が明快に成立する。

1. OpenMX（C）と openmx-rs（Rust）に同じ入力を与える
2. 各 SCF ステップの中間量（全エネルギー、固有値、密度行列、力）を比較する
3. 不一致が見つかったら、**二分探索**で原因を特定する

```
SCF ステップ 5:
  total_energy:  C = -1234.56789012   Rust = -1234.56789012   一致
  force[0].x:    C = +0.00123456      Rust = +0.00123489      不一致

AI 二分探索: "力の不一致。個別の寄与をテスト..."
  kinetic:       一致
  Hartree:       一致
  nonlocal:      不一致 → "L=2 の Gaunt 係数の位相規約が異なる。
                  OpenMX は Condon-Shortley 規約、Rust 側は
                  (-1)^m 因子を省略。修正中..."
  [修正適用、3秒で再コンパイル、再検証]
  nonlocal:      一致
  force[0].x:    一致
```

AI エージェントがこの二分探索を自律的に回せる。DFT の決定性により、各比較に曖昧さがない。「ただのノイズかもしれない」という問題がそもそも存在しない。

### 最終的に得られるもの

| 変更前（OpenMX C） | 変更後（openmx-rs） |
|--------------------|--------------------|
| 346ファイルに39万行 | Rust ワークスペース（約12 crate） |
| 330個のグローバル変数 | グローバル状態ゼロ。データは関数引数で流れる |
| 手書き Makefile（7スパコン設定） | `cargo build --release` |
| ヘッダ変更で全ファイル再コンパイル | crate 変更でその crate だけ再コンパイル |
| ユニットテストなし | 各 crate が独立にテスト可能 |
| バスファクター = 1 | AI エージェントがメンテナンス可能 |
| 手書きの力計算（12,000行） | 自動微分で置き換え可能 |
| 新 XC 汎関数追加に7ファイル修正 | `openmx-xc` で1トレイトを実装 |

**数値結果はオリジナルと同一**であることが、自動比較により検証済みだ。

---

## Part V: AI・人間統合型の開発

ここで述べた戦略は推測ではなく、既に機能しているパターンだ。

### 三つの役割

| 役割 | 担い手 |
|------|--------|
| **設計判断** | |
| 正しい抽象化を決める | 第一原理計算の物理学者 |
| crate 境界が物理的に妥当か判断する | 第一原理計算の物理学者 |
| **アーキテクチャの知見** | |
| 共有基盤と DFT 固有ロジックの境界を引く | 分野横断的研究者（第一原理 + テンソルネットワーク） |
| 分野を超えた再利用可能パターンを見出す | 分野横断的研究者 |
| DFT の crate と tenferro-rs の基盤を接続する | 分野横断的研究者 + AI |
| **実装と検証** | |
| Rust での新規実装 | AI エージェント |
| テストの記述 | AI エージェント |
| オリジナルとの二分探索検証 | AI エージェント |
| 数値の不一致の原因特定 | 物理学者 + AI |
| **自動保証** | |
| メモリ安全性 | Rust コンパイラ |
| データ競合の不在 | Rust コンパイラ |
| crate 境界とインターフェース契約の強制 | Rust コンパイラ |

### なぜ融合が重要か

人間、AI、コンパイラのいずれも、単独ではこれを成し遂げられない。

第一原理の物理学者は39万行を書き直せないし、自分が必要とする固有値ソルバーがテンソルネットワーク研究者の日常的な演算と同一であることに気づかないかもしれない。品岡らはこのつながりを見出せる。DFT とテンソルネットワークの両方を構築してきた経験から、密テンソル縮約、バッチ SVD、AD プリミティブが共有基盤であることを知っている。しかし一人で DFT コード全体を再設計・再実装はできない。AI エージェントは高速に実装できるが、抽象化が物理的に正しいかは判断できない。Rust コンパイラはメモリバグを検出しモジュール性を強制するが、物理は知らない。

三者が合わさると、完全なループが回る。

1. 物理学者：「重なり行列とハミルトニアンは別のパイプラインで構築すべきだ」
2. 分野横断的研究者：「固有値計算は tenferro-rs のバッチ線形代数を通すべきだ。テンソルネットワークと同じバックエンドを共有できる」
3. AI エージェントがコンパイル可能な Rust のトレイトと型を数秒で具現化
4. コンパイラが12 crate すべてのインターフェース整合性を検証
5. 物理学者が評価：「物理を捉えている」か「スピンの自由度の位置が違う」
6. このループが月単位ではなく分単位で回る

> **AI エージェントの時代では、書き直しはほぼ無料だ。ボトルネックはコードを書くことではなく、正しい抽象化と設計を見つけることだ。** その抽象化を見つけるには、第一原理計算の直感、分野横断的なアーキテクチャの知見、AI による高速な反復、この三者の融合が必要だ。本ドキュメント自体が、その融合の産物である。

---

## 参考文献

- [Why Rust for Julia tensor network developers](why_rusty_julia.md): テンソルネットワークコミュニティ向けの姉妹ドキュメント
- [tenferro-rs](https://github.com/tensor4all/tenferro-rs): Rust テンソル計算ワークスペース（POC）
- [OpenMX](https://www.openmx-square.org/): ケーススタディに使用した DFT コード
